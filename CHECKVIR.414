   ' ===============================================================
   '  CHECKVIR -- ver 4.14 (c) 1991 GABI MARTI & MICRO. Informtica
   ' ===============================================================
   ' Programa que compara el espai de memoria cada vegada
   ' que arrenca per evitar infeccions de virus.
   ' A partir de la versi 2.00 compara tamb la taula de Interrupcins
   ' A partir de la versi 3.00 compara la taula de particins del HD
   ' o Master Boot Record (MBR), i reescriu la informaci en cas de
   ' modificaci d'aquesta.
   ' A partir de la versi 4.00 compara el BOOT, i reescriu la informaci
   ' en cas de modificaci d'aquest.
   ' A partir de la versi 4.10 s'afegeixen els comanaments de linia i
   ' ajuda, ( opci /?  /H ).
   ' A partir de la versi 4.11 no restaura la taula de particions ni el
   ' sector d'arranc si no es possa el parametre /R. Quan restaura la MBR
   ' i el BOOT, guarda els anteriors en els fitxers CHECKANT.TPA i
   ' CHECKANT.BOT.
   ' A la versi 4.12 es corregeix el error de que no restaurava possant
   ' el parmetre /R.
   ' A la versi 4.13 s'inclou la opci /I que genera un informe de totes
   ' les comprovacions sobre el fitxer CHECKVIR.NFO
   ' A la versi 4.14 es millora la presentaci de la ajuda.
   '
   ' ATENCIO!! necessita trobar el COMMAND.COM al mateix directori; en cas
   ' contrari treur un missatge indicant que no l'ha trobat.
   '
   ' ABANS DE COMPILAR S'HA DE CARREGAR EL Quick Basic
   ' AMB ELS SEGENTS PARAMETRES:  QB /L QB.QLB
   '
   '$DYNAMIC
   '
TYPE REGTYPEX
     AX    AS INTEGER
     BX    AS INTEGER
     CX    AS INTEGER
     DX    AS INTEGER
     BP    AS INTEGER
     SI    AS INTEGER
     DI    AS INTEGER
     FLAGS AS INTEGER
     DS    AS INTEGER
     ES    AS INTEGER
END TYPE
'
DECLARE SUB SALVASEC (UNITAT%, CARA%)
DECLARE SUB AYUDA ()
DECLARE SUB PAUSA (TIC)
DECLARE SUB LINEDISPLAY (TEXTE$, LIN%, COL%, NUM%)
DECLARE SUB WRITESEC (UNITAT%, CARA%)
DECLARE FUNCTION RESTAURA! (UNITAT%, CARA%)
DECLARE FUNCTION COMPBOOT! (UNITAT%)
DECLARE FUNCTION COMPTPA (UNITAT%)
DECLARE SUB READSEC (UNITAT%, CARA%)
DECLARE SUB INTERRUPTX (intnum AS INTEGER, INREG AS REGTYPEX, OUTREG AS REGTYPEX)
DECLARE SUB PANTALLA (MEN$)
   '
   UNITAT% = &H80
   ' LONGITUD EN BYTES DEL PROGRAMA CHECKVIR.EXE
   LPRO = 67642
   ' DEFINICIO VARIABLES CAPALERA
   PRO$ = "GABI MARTI I FUENTES.           "
   AUT$ = "MICRO. Informtica Calella S.L. "
   ' PROTECCIO CONTRA MODIFICACIONS DE LITERALS
   IF LCASE$(LEFT$(AUT$, 1)) <> "m" THEN GOTO ERRR
   IF MID$(AUT$, 6, 1) <> "." THEN GOTO ERRR
   IF MID$(AUT$, 14, 1) <> "" THEN GOTO ERRR
   IF LEFT$(PRO$, 1) <> "G" OR MID$(PRO$, 12, 1) <> "I" THEN GOTO ERRR
   IF RIGHT$(PRO$, 6) <> "      " OR MID$(PRO$, 17, 1) <> "N" THEN GOTO ERRR
   ' COMPROVACIO DE SI S'HA ACTIVAT LA OPCIO D'AJUDA
   IF INSTR(COMMAND$, "/?") > 0 OR INSTR(UCASE$(COMMAND$), "/H") > 0 THEN
      CALL AYUDA
      END
   END IF
   ' COMPROVACIO DE SI S'HA ACTIVAT LA OPCIO DE GENERAR INFORME
   IF INSTR(UCASE$(COMMAND$), "/I") > 0 THEN
      INFO% = 1
   ELSE
      INFO% = 0
   END IF
   ' COMPROVACIO DE SI S'HA ACTIVAT LA OPCIO DE RESTAURAR MBR I BOOT
   IF INSTR(UCASE$(COMMAND$), "/R") > 0 THEN
      REST% = 1
   ELSE
      REST% = 0
   END IF
   ' COMPROVACIO DE SI S'HA ACTIVAT LA OPCIO DE VISUALITZAR NOM D'AUTOR
   IF INSTR(UCASE$(COMMAND$), "/A") > 0 THEN
      CALL PANTALLA(PRO$)
   ELSE
      CALL PANTALLA(AUT$)
   END IF
   ' MIRO SI SE HA ENTRAT EL PARAMETRE /D unitat PER SELLECCIONAR UNA
   ' UNITAT DIFERENTE DE LA &H80 (C:)
   P% = INSTR(UCASE$(COMMAND$), "/D")
   IF P% > 0 THEN
      UNITAT% = VAL(MID$(COMMAND$, P% + 2))
   END IF
   LIMEN% = 6
   ' COS PRINCIPAL
   IF INFO% = 1 THEN
      OPEN "CHECKVIR.NFO" FOR OUTPUT AS #5
      PRINT #5, "  Ŀ   "
      PRINT #5, "    CHECKVIR   ver. 4.14   -  I N F O R M E  -   "
      PRINT #5, "    "
      PRINT #5, "     "
      PRINT #5, " "
      PRINT #5, "  COMPROBACION            V. ESPERADO   V. DETECTADO  DIAGNOSTICO           "
      PRINT #5, "    "
         NFO$ = " \                     \ #,###,###,### #,###,###,### \                     \"
         NFH$ = " \                     \  \          \  \          \ \                     \"
   END IF
   GOSUB FITXER.COMPROBACIO
   DEF SEG = 0
   MKB = PEEK(&H413) + 256 * PEEK(&H414)
   CR1 = FRE(0)
   CR2 = FRE(-1)
   OPEN "COMMAND.COM" FOR RANDOM ACCESS READ AS #1
   IF LOF(1) <> 0 THEN
      CLOSE #1
      OPEN "COMMAND.COM" FOR INPUT AS #1
      LCO = LOF(1)
      CLOSE #1
   ELSE
      CLOSE #1
      LCO = 0
      LOCATE LIMEN%, 56: PRINT "COMMAND.COM NO EXISTE"
      LIMEN% = LIMEN% + 1
      KILL "COMMAND.COM"
   END IF
   OPEN "CHECKVIR.EXE" FOR INPUT AS #1
    LCH = LOF(1)
   CLOSE #1
   VIRUS% = 0
   IF MEMKB = MKB THEN
      OK1$ = " CORRECTO"
   ELSE
      OK1$ = "INCORRECTO"
      LOCATE LIMEN%, 56: PRINT "CAPACIDAD MEMORIA RAM"
      LIMEN% = LIMEN% + 1
      LOCATE LIMEN%, 56: PRINT "HA SIDO MODIFICADA. "
      LIMEN% = LIMEN% + 1
      VIRUS% = 1
      SOUND 4000, .1: SOUND 1660, .1: SOUND 500, .15
   END IF
   IF INFO% = 1 THEN PRINT #5, USING NFO$; "MEMORIA RAM BASE"; MEMKB; MKB; OK1$
   IF CRC1 = CR1 THEN
      OK2$ = " CORRECTO"
   ELSE
      OK2$ = "INCORRECTO"
      LOCATE LIMEN%, 56: PRINT "MEMORIA ALTERADA."
      LIMEN% = LIMEN% + 1
      VIRUS% = VIRUS% + 1
   END IF
   IF INFO% = 1 THEN PRINT #5, USING NFO$; "CRC #1"; CRC1; CR1; OK2$
   IF CRC2 = CR2 THEN
      OK3$ = " CORRECTO "
   ELSE
      OK3$ = "INCORRECTO"
      LOCATE LIMEN%, 56: PRINT "MEMORIA ALTERADA."
      LIMEN% = LIMEN% + 1
      VIRUS% = VIRUS% + 1
   END IF
   IF INFO% = 1 THEN PRINT #5, USING NFO$; "CRC #2"; CRC2; CR2; OK3$
   IF LCOM = LCO THEN
      OK5$ = " CORRECTO "
   ELSE
      OK5$ = "INCORRECTO"
      LOCATE LIMEN%, 56: PRINT "COMMAND.COM INFECTADO."
      LIMEN% = LIMEN% + 1
      VIRUS% = VIRUS% + 1
   END IF
   IF INFO% = 1 THEN PRINT #5, USING NFO$; "LONGITUD COMMAND.COM"; LCOM; LCO; OK5$
   IF INFO% = 1 AND LCO = 0 THEN PRINT #5, USING NFH$; " >"; ""; ""; "COMMAND.COM NO ENCONTRADO"
   IF LPRO = LCH THEN
      OK6$ = " CORRECTO "
   ELSE
      OK6$ = "INCORRECTO"
      LOCATE LIMEN%, 56: PRINT "CHECKVIR.EXE INFECTADO."
      LIMEN% = LIMEN% + 1
      VIRUS% = VIRUS% + 1
   END IF
   IF INFO% = 1 THEN PRINT #5, USING NFO$; "LONGITUD CHECKVIR.EXE"; LPRO; LCH; OK6$
   LOCATE 6, 33: PRINT USING "###,###"; MKB; : PRINT " Kb"; : LOCATE 6, 45: PRINT OK1$
   LOCATE 7, 33: PRINT USING "###,###"; CR1; : LOCATE 7, 45: PRINT OK2$
   LOCATE 8, 33: PRINT USING "###,###"; CR2; : LOCATE 8, 45: PRINT OK3$
   LOCATE 9, 33: PRINT USING "###,###"; LCO; : LOCATE 9, 45: PRINT OK5$
   LOCATE 10, 33: PRINT USING "###,###"; LCH; : LOCATE 10, 45: PRINT OK6$
   GOSUB COMPROVA.INT
   CORRE1% = 0
   CORRE2% = 0
   CORRE1% = COMPTPA(UNITAT%)
   CORRE2% = COMPBOOT(UNITAT%)
   COLOR 0, 7
   LOCATE 24, 1: PRINT SPACE$(80);
   IF VIRUS% > 0 THEN
      M$ = "*** Posible infeccin vrica. ***          "
      M$ = M$ + " Llamar a MICRO. Informtica Calella S.L. - Telf. (93) 769.43.12 ;"
      M$ = M$ + "    PULSE [RETURN] PARA TERMINAR ...     "
      CALL LINEDISPLAY(M$, 24, 1, 80)
   ELSE
      LOCATE 24, 5: PRINT " Sistema correcto.   Pulse una tecla para salir ... ";
      K$ = INPUT$(1)
   END IF
   COLOR 7, 0
   PRINT
   END
ERRR:
   CLS
   PRINT "Ŀ"
   PRINT " Packed file is corrupt ... "
   PRINT ""
   PRINT CHR$(7); CHR$(7); CHR$(7); CHR$(7);
   END
'
'
FITXER.COMPROBACIO:
'
   OPEN "CHECKVIR.BOT" FOR RANDOM AS #1
   IF LOF(1) = 0 THEN
      CLOSE #1
      CALL READSEC(UNITAT%, 1)
   END IF
   CLOSE #1
   OPEN "CHECKVIR.TPA" FOR RANDOM AS #1
   IF LOF(1) = 0 THEN
      CLOSE #1
      CALL READSEC(UNITAT%, 0)
   END IF
   CLOSE #1
   OPEN "CHECKVIR.CRC" FOR RANDOM AS #1
   IF LOF(1) = 0 THEN GOSUB CREA.CRC
   CLOSE #1
   OPEN "CHECKVIR.CRC" FOR INPUT AS #1
    INPUT #1, MEMKB
    INPUT #1, CRC1
    INPUT #1, CRC2
    INPUT #1, LCOM
   CLOSE #1
   OPEN "CHECKVIR.INT" FOR RANDOM AS #1
   IF LOF(1) = 0 THEN GOSUB CREA.INT
   CLOSE #1
RETURN
'
COMPROVA.INT:
   RESTORE
   COLOR 0, 7
   LOCATE 24, 1: PRINT SPACE$(80);
   COLOR 7, 0
   CLOSE #1
   IF INFO% = 1 THEN
      PRINT #5, " "
      PRINT #5, USING NFH$; "VECTORES INTERRUPCION"; ""; ""; ""
   END IF
   OPEN "CHECKVIR.INT" FOR INPUT AS #1
   LIN% = 14
   FOR i% = &H0 TO &H77
       IF LIN% > 18 THEN
          FOR X% = 14 TO 18
              LOCATE X%, 3: PRINT SPACE$(28)
              LOCATE X%, 33: PRINT SPACE$(8)
              LOCATE X%, 45: PRINT SPACE$(10)
          NEXT X%
          LIN% = 14
       END IF
       INPUT #1, FC1%
       INPUT #1, FC2%
       INPUT #1, FC3%
       INPUT #1, FC4%
       DEF SEG = 0
       VL1% = PEEK(i%)
       VL2% = PEEK(i% + 1)
       VL3% = PEEK(i% + 2)
       VL4% = PEEK(i% + 3)
       READ IN$
       LOCATE LIN%, 3: PRINT HEX$(i%); " "; IN$
       LOCATE LIN%, 33: PRINT HEX$(FC1%); HEX$(FC2%); HEX$(FC3%); HEX$(FC4%)
       IF VL1% <> FC1% OR VL2% <> FC2% OR VL3% <> FC3% OR VL4% <> FC4% THEN
           OKI$ = "INCORRECTO"
           SOUND 3600, .1: SOUND 660, .1
           VIRUS% = VIRUS% + 1
           IF LIMEN% < 20 THEN
             LOCATE LIMEN%, 56: PRINT HEX$(i%); " "; IN$;
             LIMEN% = LIMEN% + 1
           END IF
       ELSE
           OKI$ = " CORRECTO "
       END IF
       LOCATE LIN%, 45: PRINT OKI$;
       IF INFO% = 1 THEN PRINT #5, USING NFH$; "  " + IN$; HEX$(FC1%) + HEX$(FC2%) + HEX$(FC3%) + HEX$(FC4%); HEX$(VL1%) + HEX$(VL2%) + HEX$(VL3%) + HEX$(VL4%); OKI$
       LIN% = LIN% + 1
   NEXT i%
   CLOSE #1
   IF INFO% = 1 THEN PRINT #5, USING NFH$; ""; ""; ""; ""
RETURN
'
'
CREA.INT:
   CLOSE #1
   COLOR 0, 7
   LOCATE 24, 1: PRINT SPACE$(80);
   LOCATE 24, 1: PRINT " Creacin fichero vectores interrupcin ..."; CHR$(7);
   COLOR 7, 0
   OPEN "CHECKVIR.INT" FOR OUTPUT AS #1
   FOR i% = &H0 TO &H77
       COLOR 0, 7
       LOCATE 24, 65: PRINT HEX$(i%);
       COLOR 7, 0
       DEF SEG = 0
       VL1% = PEEK(i%)
       VL2% = PEEK(i% + 1)
       VL3% = PEEK(i% + 2)
       VL4% = PEEK(i% + 3)
       PRINT #1, VL1%
       PRINT #1, VL2%
       PRINT #1, VL3%
       PRINT #1, VL4%
   NEXT i%
   CLOSE #1
RETURN
'
CREA.CRC:
   CLOSE #1
   COLOR 0, 7
   LOCATE 24, 1: PRINT SPACE$(80);
   LOCATE 24, 1: PRINT " Creacin del fichero de comprobacin ..."; CHR$(7);
   COLOR 7, 0
   DEF SEG = 0
   MEMKB = PEEK(&H413) + 256 * PEEK(&H414)
   CRC1 = FRE(0)
   CRC2 = FRE(-1)
   OPEN "COMMAND.COM" FOR RANDOM ACCESS READ AS #1
   IF LOF(1) <> 0 THEN
      CLOSE #1
      OPEN "COMMAND.COM" FOR INPUT AS #1
      LCOM = LOF(1)
      CLOSE #1
   ELSE
      CLOSE #1
      LCOM = 0
      LOCATE LIMEN%, 56: PRINT "COMMAND.COM NO EXISTE"
      LIMEN% = LIMEN% + 1
      KILL "COMMAND.COM"
   END IF
   OPEN "CHECKVIR.CRC" FOR OUTPUT AS #1
    PRINT #1, MEMKB
    PRINT #1, CRC1
    PRINT #1, CRC2
    PRINT #1, LCOM
   CLOSE #1
RETURN
'
'
DATA DIVISION POR CERO, PASO A PASO, NMI, RUPTURA, DESBORDAMIENTO, TECLA PrtSc
DATA RESERVADA, RESERVADA, IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7
DATA VIDEO BIOS, EQUIPO BIOS, TAMAO BIOS, DISCO BIOS, COMUNICACIONES BIOS
DATA E/S BIOS, TECLADO BIOS, IMPRESORA BIOS, BASIC, LOAD BIOS
DATA HORA BIOS, BREAK BIOS, TEMPORIZADOR BIOS, PARAMETROS BIOS, FLOPPY BIOS
DATA CARACTERES BIOS, FIN PROCESO DOS, FUNCIONES DOS, ADR. FIN DOS
DATA CTRL-C DOS, ERROR DOS, LECTURA DISCO DOS, ESCRITURA DISCO DOS
DATA RESIDENTE DOS, ESPERA DOS, RESERVADA DOS, RED DOS
DATA RESERVADA DOS, RESERVADA DOS, RESERVADA DOS, RESERVADA DOS
DATA MULTIPLEX DOS
DATA RESERVADA DOS, RESERVADA DOS, RESERVADA DOS, RESERVADA DOS
DATA RESERVADA DOS, RESERVADA DOS, RESERVADA DOS, RESERVADA DOS
DATA RESERVADA DOS, RESERVADA DOS, RESERVADA DOS, RESERVADA DOS
DATA RESERVADA DOS, RESERVADA DOS, RESERVADA DOS, RESERVADA DOS
DATA FLOPPY BIOS, HARD DISK BIOS, EGA BIOS
DATA TABLA EGA BIOS, CARACTERES BIOS, N/D, PARM. HD BIOS
DATA N/D, N/D, N/D, ALARMA BIOS
DATA N/D, N/D, N/D, N/D, N/D
DATA N/D, N/D, N/D, N/D, N/D
DATA N/D, N/D, N/D, N/D, N/D
DATA ADAPTADOR BLOQUES, PROGRAMA BLOQUES
DATA N/D, N/D, N/D, N/D
DATA USUARIO, USUARIO, USUARIO, USUARIO, USUARIO, USUARIO, USUARIO
DATA DRIVER LIM EMS
DATA N/D, N/D, N/D, N/D, N/D, N/D, N/D, N/D
DATA IRQ8, IRQ9 A IRQ2, IRQ10, IRQ11, IRQ12
DATA IRQ13, IRQ14, RESERVADO IRQ15

REM $STATIC
SUB AYUDA
    K$ = ""
    PAG = 1
    DO WHILE K$ <> CHR$(27)
       ' PgDn
       IF K$ = CHR$(0) + CHR$(&H51) THEN PAG = PAG + 1
       ' PgUp
       IF K$ = CHR$(0) + CHR$(&H49) THEN PAG = PAG - 1
       ' CONTROL OVERFLOW
       IF PAG < 1 THEN PAG = 1
       IF PAG > 4 THEN PAG = 4
       COLOR 15, 3
       ON PAG GOSUB PANTALLA1, PANTALLA2, PANTALLA3, PANTALLA4
       COLOR 1, 7
       LOCATE 24, 1
       PRINT "     [Esc] - Salir    [PgDn] - Pgina Siguiente    [PgUp] - Pgina Anterior     ";
       COLOR 7, 0
       K$ = ""
       DO WHILE K$ = ""
          K$ = INKEY$
       LOOP
    LOOP
    CLS
    EXIT SUB
PANTALLA1:
    CLS
    PRINT " Ŀ "
    PRINT "   CHECKVIR   *************** A Y U D A **************          Pgina 1/4   "
    PRINT " Ĵ "
    PRINT "   (c)1991,92  MICRO. Informtica Calella S.L.  &  Gabriel Marti i Fuentes    "
    PRINT " ĳ "
    PRINT "                                                                              "
    PRINT "  Checkvir es una utilidad NO RESIDENTE que avisa de la intrusin de virus en "
    PRINT "  el sistema, basandose en la comprobacin de unos ficheros patrn que se     "
    PRINT "  crean la primera vez que se ejecuta Checkvir. Por lo tanto es imprescin-    "
    PRINT "  dible que el sistema est 'limpio' la primera vez que se ejecute Checkvir,  "
    PRINT "  sin no servir de nada su instalacin.                                     "
    PRINT "                                                                              "
    PRINT "  Para que su funcionamiento sea correcto debe instalarse en el AUTOEXEC.BAT  "
    PRINT "  siendo ademas la primera instruccin que se ejecute, as si modificamos el  "
    PRINT "  los ficheros que cargamos en el AUTOEXEC, no afectar al funcionamiento de  "
    PRINT "  Checkvir, ya que si ejecutamos programas residentes, puede darnos errores.  "
    PRINT "                                                                              "
    PRINT "  No debe de ejecutarse desde la linea de comandos del DOS, pus nos daria    "
    PRINT "  errores en las lineas de CRC, i en algunos Vectores de Interrupcin, por lo "
    PRINT "  tanto para saber si ha habido intrusin de virus se debe reinicializar el   "
    PRINT "  ordenador haciendo un reset, o parrlo y conectarlo.                        "
    PRINT "                                                                              "
    PRINT "  "
RETURN

PANTALLA2:
    CLS
    PRINT " Ŀ "
    PRINT "   CHECKVIR   *************** A Y U D A **************          Pgina 2/4   "
    PRINT " Ĵ "
    PRINT "   RELACION DE FICHEROS QUE CREA Y UTILIZA:                                   "
    PRINT " ĳ "
    PRINT "                                                                              "
    PRINT "   CHECKVIR.CRC : Contiene las capacidades de memoria, los CRC's y la lon-    "
    PRINT "                  gitud del fichero COMMAND.COM.                              "
    PRINT "                                                                              "
    PRINT "   CHECKVIR.INT : Tiene las direcciones de los Vectores de Interrupcin.      "
    PRINT "                                                                              "
    PRINT "   CHECKVIR.TPA : Contiene la MBR,  Tabla de Particiones.                    "
    PRINT "                                                                              "
    PRINT "   CHECKVIR.BOT : Contiene el BOOT, o sea el Arranque del DOS.                "
    PRINT "                                                                              "
    PRINT "   CHECKANT.TPA : Contiene la MBR anterior cuando se restaura la original.    "
    PRINT "                                                                              "
    PRINT "   CHECKANT.BOT : Contiene el BOOT anterior cuando se restaura el original.   "
    PRINT "                                                                              "
    PRINT "   CHECKVIR.NFO : Contiene el Informe de las comprobaciones cuando se utiliza "
    PRINT "                  la opcin /I.                                               "
    PRINT "                                                                              "
    PRINT "  "
RETURN

PANTALLA3:
    CLS
    PRINT " Ŀ "
    PRINT "   CHECKVIR   *************** A Y U D A **************          Pgina 3/4   "
    PRINT " Ĵ "
    PRINT "   FORMATO:   CHECKVIR [opciones]                                             "
    PRINT " ĳ "
    PRINT "   OPCIONES:                                                                  "
    PRINT "      /?  /H   : Muestra la Ayuda.                                           "
    PRINT "      /D unidad : Donde la unidad es por defecto &H80 que corresponde al      "
    PRINT "                  primer disco duro.                                          "
    PRINT "                  UNIDAD:                                                     "
    PRINT "                          &H80 - PRIMER DISCO DURO  (* valor por defecto *)   "
    PRINT "                          &H81 - SEGUNDO DISCO DURO                           "
    PRINT "      /R        : Restaura la Tabla de Particiones (MBR) y el Sector de       "
    PRINT "                  Arranque (BOOT), en caso de que sean erroneos.              "
    PRINT "      /I        : Genera el fichero CHECKVIR.NFO con el resultado de todas    "
    PRINT "                  las comprobaciones.                                         "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT " ĳ "
    PRINT "                                                                              "
    PRINT "  "
RETURN

PANTALLA4:
    CLS
    PRINT " Ŀ "
    PRINT "   CHECKVIR   *************** A Y U D A **************          Pgina 4/4   "
    PRINT " Ĵ "
    PRINT "                                                                              "
    PRINT " ĳ "
    PRINT "                                                                              "
    PRINT "      Programado enteramente en Quick Basic ver. 4.5                          "
    PRINT "                                                                              "
    PRINT "      Programacin y diseo:                                                  "
    PRINT "                                                                              "
    PRINT "               GABRIEL MARTI I FUENTES                                        "
    PRINT "                                                       "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "      (c)1991,92  MICRO. Informtica Calella S.L.                             "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "         Versin 4.14 - 12/Marzo/1992                                         "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT " ĳ "
    PRINT "                                                                              "
    PRINT "  "
RETURN

PANTPATRO:
    CLS
    PRINT " Ŀ "
    PRINT "   CHECKVIR   *************** A Y U D A **************          Pgina 4/4   "
    PRINT " Ĵ "
    PRINT "   (c)1991,92  Gabriel Marti i Fuentes                                        "
    PRINT " ĳ "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT "                                                                              "
    PRINT " ĳ "
    PRINT "  PANTALLA RESERVADA PARA VERSIONES POSTERIORES ...                           "
    PRINT "  "
RETURN
END SUB

FUNCTION COMPBOOT (UNITAT%)
SHARED LIMEN%, INFO%, NFH$
DIM INREG AS REGTYPEX        ' REGISTRES DE ENTRADA
DIM OUTREG AS REGTYPEX       ' REGISTRES DE SORTIDA
DIM SEC%(1 TO 512)           ' SECTOR

INREG.AX = &H201             ' FUNCIO 2  - LLEGIR 1 SECTOR
INREG.CX = &H1               ' CILINDRE 0, SECTOR 1
INREG.DX = 256 + UNITAT%     ' CAPAL 1, UNITAT 80 (C:)
INREG.ES = VARSEG(SEC%(1))   ' SEGMENT DE DADES
INREG.BX = VARPTR(SEC%(1))   ' OFFSET DE DADES
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Leyendo (BOOT) de Unidad "; HEX$(UNITAT%); " ...";
COLOR 7, 0
CALL INTERRUPTX(&H13, INREG, OUTREG)
CALL INTERRUPTX(&H13, INREG, OUTREG)
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Comparando (BOOT) con fichero CHECKVIR.BOT ...";
COLOR 7, 0
OPEN "CHECKVIR.BOT" FOR RANDOM AS #1 LEN = 2
FIELD #1, 2 AS BYTE2$
MAL% = 0
FOR i% = 1 TO 512
   GET #1, i%
   IF SEC%(i%) <> CVI(BYTE2$) THEN MAL% = MAL% + 1
NEXT i%
CLOSE #1
OK% = 1
IF MAL% > 0 THEN
   OK$ = "INCORRECTO"
   LOCATE LIMEN%, 56: PRINT "BOOT ERRONEO"
   LIMEN% = LIMEN% + 1
   LOCATE 21, 45: PRINT OK$
   OK% = RESTAURA(UNITAT%, 1)
ELSE
   OK$ = " CORRECTO "
   LOCATE 21, 45: PRINT OK$
END IF
IF INFO% = 1 THEN
   PRINT #5, USING NFH$; "SECTOR DE ARRANQUE"; ""; ""; OK$
   IF MAL% > 0 THEN
     IF OK% = 1 THEN
        PRINT #5, USING NFH$; " >"; ""; ""; "CORREGIDO"
     ELSE
        PRINT #5, USING NFH$; " >"; ""; ""; "NO CORREGIDO"
     END IF
   END IF
END IF
COMPBOOT = OK%
END FUNCTION

FUNCTION COMPTPA (UNITAT%)
SHARED LIMEN%, INFO%, NFH$
DIM INREG AS REGTYPEX        ' REGISTRES DE ENTRADA
DIM OUTREG AS REGTYPEX       ' REGISTRES DE SORTIDA
DIM SEC%(1 TO 512)           ' SECTOR

INREG.AX = &H201             ' FUNCIO 2  - LLEGIR 1 SECTOR
INREG.CX = &H1               ' CILINDRE 0, SECTOR 1
INREG.DX = UNITAT%           ' CAPAL 0, UNITAT 80 (C:)
INREG.ES = VARSEG(SEC%(1))   ' SEGMENT DE DADES
INREG.BX = VARPTR(SEC%(1))   ' OFFSET DE DADES
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Leyendo (MBR) de Unidad "; HEX$(UNITAT%); " ...";
COLOR 7, 0
CALL INTERRUPTX(&H13, INREG, OUTREG)
CALL INTERRUPTX(&H13, INREG, OUTREG)
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Comparando (MBR) con fichero CHECKVIR.TPA ...";
COLOR 7, 0
OPEN "CHECKVIR.TPA" FOR RANDOM AS #1 LEN = 2
FIELD #1, 2 AS BYTE2$
MAL% = 0
FOR i% = 1 TO 512
   GET #1, i%
   IF SEC%(i%) <> CVI(BYTE2$) THEN MAL% = MAL% + 1
NEXT i%
CLOSE #1
OK% = 1
IF MAL% > 0 THEN
   OK$ = "INCORRECTO"
   LOCATE LIMEN%, 56: PRINT "MBR ERRONEO"
   LIMEN% = LIMEN% + 1
   LOCATE 20, 45: PRINT OK$
   OK% = RESTAURA(UNITAT%, 0)
ELSE
   OK$ = " CORRECTO "
   LOCATE 20, 45: PRINT OK$
END IF
IF INFO% = 1 THEN
   PRINT #5, USING NFH$; "MASTER BOOT RECORD"; ""; ""; OK$
   IF MAL% > 0 THEN
     IF OK% = 1 THEN
        PRINT #5, USING NFH$; " >"; ""; ""; "CORREGIDO"
     ELSE
        PRINT #5, USING NFH$; " >"; ""; ""; "NO CORREGIDO"
     END IF
   END IF
END IF
COMPTPA = OK%
END FUNCTION

SUB LINEDISPLAY (TEXTE$, LIN%, COL%, NUM%)
    X$ = ""
    TEXTE$ = SPACE$(NUM% - 1) + TEXTE$
    L% = LEN(TEXTE$)
    P% = 1
    SOUND 3000, .15
    DO
       LOCATE LIN%, COL%
       D$ = MID$(TEXTE$, P%, NUM%)
       IF LEN(D$) < NUM% THEN
          D$ = D$ + SPACE$(NUM% - LEN(D$))
       END IF
       LOCATE LIN%, COL%: PRINT D$;
       P% = P% + 1
       IF P% > L% THEN P% = 1: SOUND 3000, .15
       SOUND 2000, .05
       PAUSA (.152)
       X$ = INKEY$
    LOOP UNTIL X$ = CHR$(13)
    EXIT SUB
END SUB

SUB PANTALLA (MEN$)
   CLS
   LOCATE 1, 1: PRINT "Ŀ"
   LOCATE 2, 1: PRINT ""; : COLOR 0, 7
   PRINT " Checkvir   v 4.14                (c)1991,92 " + MEN$;
   COLOR 7, 0: PRINT ""
   LOCATE 3, 1:  PRINT "Ĵ"
   LOCATE 4, 1:  PRINT "                                 Valores     Estado     Mensajes / Errores    "
   LOCATE 5, 1:  PRINT "Ŀ"
   LOCATE 6, 1:  PRINT " MEMORIA RAM BASE                                               "
   LOCATE 7, 1:  PRINT " CRC #1                                               "
   LOCATE 8, 1:  PRINT " CRC #2                                               "
   LOCATE 9, 1:  PRINT " LONGITUD COMMAND.COM                                               "
   LOCATE 10, 1: PRINT " LONGITUD CHECKVIR.EXE                                               "
   LOCATE 11, 1: PRINT "ͳ                                             "
   LOCATE 12, 1: PRINT " TABLA VECTORES INTERRUPCION                                             "
   LOCATE 13, 1: PRINT "ĳ                                             "
   LOCATE 14, 1: PRINT "                                                                         "
   LOCATE 15, 1: PRINT "                                                                         "
   LOCATE 16, 1: PRINT "                                                                         "
   LOCATE 17, 1: PRINT "                                                                         "
   LOCATE 18, 1: PRINT "                                                                         "
   LOCATE 19, 1: PRINT "ͳ                                             "
   LOCATE 20, 1: PRINT " TABLA DE PARTICIONES (MBR)                                              "
   LOCATE 21, 1: PRINT " SECTOR DE ARRANQUE (BOOT)                                               "
   LOCATE 22, 1: PRINT "ٳ"
   LOCATE 23, 1: PRINT "";
   COLOR 0, 7
   LOCATE 24, 1: PRINT SPACE$(80);
   COLOR 7, 0
END SUB

SUB PAUSA (TIC)
    INIT = TIMER
    DO
     REM
    LOOP UNTIL (TIMER > INIT + TIC)
END SUB

SUB READSEC (UNITAT%, CARA%)
DIM INREG AS REGTYPEX        ' REGISTRES DE ENTRADA
DIM OUTREG AS REGTYPEX       ' REGISTRES DE SORTIDA
DIM SEC%(1 TO 512)           ' SECTOR

INREG.AX = &H201                  ' FUNCIO 2  - LLEGIR 1 SECTOR
INREG.CX = &H1                    ' CILINDRE 0, SECTOR 1
INREG.DX = 256 * CARA% + UNITAT%  ' CAPAL CARA%, UNITAT 80 (C:)
INREG.ES = VARSEG(SEC%(1))        ' SEGMENT DE DADES
INREG.BX = VARPTR(SEC%(1))        ' OFFSET DE DADES
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
IF CARA% = 0 THEN
   L$ = "(MBR)": FICH$ = "CHECKVIR.TPA"
ELSE
   L$ = "(BOOT)": FICH$ = "CHECKVIR.BOT"
END IF
LOCATE 24, 1: PRINT " Leyendo "; L$; " de Unidad "; HEX$(UNITAT%); " ...";
COLOR 7, 0
CALL INTERRUPTX(&H13, INREG, OUTREG)
CALL INTERRUPTX(&H13, INREG, OUTREG)
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Guardando "; L$; " en fichero "; FICH$; " ..."; CHR$(7);
COLOR 7, 0
OPEN FICH$ FOR RANDOM AS #1 LEN = 2
FIELD #1, 2 AS BYTE2$
FOR i% = 1 TO 512
   LSET BYTE2$ = MKI$(SEC%(i%))
   PUT #1, i%
NEXT i%
CLOSE #1
END SUB

FUNCTION RESTAURA (UNITAT%, CARA%)
    SHARED REST%
    COLOR 0, 7
    LOCATE 24, 1: PRINT SPACE$(80);
    IF REST% = 1 THEN
      IF CARA% = 0 THEN
         LOCATE 24, 1: PRINT " Restaurar TABLA DE PARTICIONES (MBR) [s/n]? ..."; CHR$(7);
      ELSE
         LOCATE 24, 1: PRINT " Restaurar SECTOR DE ARRANQUE  (BOOT) [s/n]? ..."; CHR$(7);
      END IF
      COLOR 7, 0
      SOUND 2000, .2
      SOUND 1300, .15
      K$ = ""
      DO WHILE K$ <> "S" AND K$ <> "N" AND K$ <> CHR$(27)
         K$ = UCASE$(INKEY$)
      LOOP
    ELSE
      K$ = "N"
    END IF
    COLOR 7, 0
    IF K$ = "S" THEN
       CALL SALVASEC(UNITAT%, CARA%)
       CALL WRITESEC(UNITAT%, CARA%)
       IF CARA% = 0 THEN
          LOCATE 20, 56: PRINT "MBR CORREGIDO     "
       ELSE
          LOCATE 21, 56: PRINT "BOOT CORREGIDO    "
       END IF
       RESTAURA = 1
    ELSE
       IF CARA% = 0 THEN
          LOCATE 20, 56: PRINT "MBR NO CORREGIDO  "
       ELSE
          LOCATE 21, 56: PRINT "BOOT NO CORREGIDO "
       END IF
       RESTAURA = 0
    END IF
END FUNCTION

SUB SALVASEC (UNITAT%, CARA%)
DIM INREG AS REGTYPEX             ' REGISTRES DE ENTRADA
DIM OUTREG AS REGTYPEX            ' REGISTRES DE SORTIDA
DIM SEC%(1 TO 512)                ' SECTOR

INREG.AX = &H201                  ' FUNCIO 2  - LLEGIR 1 SECTOR
INREG.CX = &H1                    ' CILINDRE 0, SECTOR 1
INREG.DX = 256 * CARA% + UNITAT%  ' CAPAL CARA%, UNITAT 80 (C:)
INREG.ES = VARSEG(SEC%(1))        ' SEGMENT DE DADES
INREG.BX = VARPTR(SEC%(1))        ' OFFSET DE DADES
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
IF CARA% = 0 THEN
   L$ = "(MBR)": FICH$ = "CHECKANT.TPA"
ELSE
   L$ = "(BOOT)": FICH$ = "CHECKANT.BOT"
END IF
LOCATE 24, 1: PRINT " Leyendo "; HEX$(UNITAT%); " ...";
COLOR 7, 0
CALL INTERRUPTX(&H13, INREG, OUTREG)
CALL INTERRUPTX(&H13, INREG, OUTREG)
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Salvando " + L$ + " en fichero " + FICH$ + " ..."; CHR$(7);
COLOR 7, 0
OPEN FICH$ FOR RANDOM AS #1 LEN = 2
FIELD #1, 2 AS BYTE2$
FOR i% = 1 TO 512
   LSET BYTE2$ = MKI$(SEC%(i%))
   PUT #1, i%
NEXT i%
CLOSE #1
END SUB

SUB WRITESEC (UNITAT%, CARA%)
DIM INREG AS REGTYPEX        ' REGISTRES DE ENTRADA
DIM OUTREG AS REGTYPEX       ' REGISTRES DE SORTIDA
DIM SEC%(1 TO 512)           ' SECTOR

INREG.AX = &H301                    ' FUNCIO 3  - ESCRIURE 1 SECTOR
INREG.CX = &H1                      ' CILINDRE 0, SECTOR 1
INREG.DX = 256 * CARA% + UNITAT%    ' CAPAL CARA%, UNITAT 80 (C:)
INREG.ES = VARSEG(SEC%(1))          ' SEGMENT DE DADES
INREG.BX = VARPTR(SEC%(1))          ' OFFSET DE DADES
IF CARA% = 0 THEN
   L$ = "(MBR)": FICH$ = "CHECKVIR.TPA"
ELSE
   L$ = "(BOOT)": FICH$ = "CHECKVIR.BOT"
END IF
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Leyendo "; L$; " del fichero "; FICH$; " ...";
COLOR 7, 0
PUN% = 1
OPEN FICH$ FOR RANDOM AS #1 LEN = 2
FIELD #1, 2 AS BYTE2$
FOR i% = 1 TO 512
   GET #1, i%
   SEC%(i%) = CVI(BYTE2$)
NEXT i%
CLOSE #1
COLOR 0, 7
LOCATE 24, 1: PRINT SPACE$(80);
LOCATE 24, 1: PRINT " Escribiendo "; L$; " en Unidad "; HEX$(UNITAT%); " ..."; CHR$(7);
COLOR 7, 0
CALL INTERRUPTX(&H13, INREG, OUTREG)
CALL INTERRUPTX(&H13, INREG, OUTREG)
END SUB

